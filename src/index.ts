import {
  app,
  BrowserWindow,
  dialog,
  ipcMain,
  systemPreferences,
} from "electron";

import { TrackAudioAfv, AfvEventTypes } from "trackaudio-afv";
import { Configuration } from "./config.d";
import Store from "electron-store";
import { uIOhook, UiohookKey } from "uiohook-napi";
import * as Sentry from "@sentry/electron/main";

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// The increment for window zoom with each mouse wheel movement
const ZOOM_DELTA = 0.2;

Sentry.init({
  dsn: "https://79ff6300423d5708cae256665d170c4b@o4507193732169728.ingest.de.sentry.io/4507193745145936",
  enabled: false,
  sendDefaultPii: false,
});

let version = "";
let mainWindow: BrowserWindow;

let isSettingPtt = false;

const keycodeMap = new Map(Object.entries(UiohookKey).map((_) => [_[1], _[0]]));

let currentConfiguration: Configuration = {
  audioApi: -1,
  audioInputDeviceId: "",
  headsetOutputDeviceId: "",
  speakerOutputDeviceId: "",
  cid: "",
  password: "",
  callsign: "",
  pttKey: 0,
  pttKeyName: "None",
  hardwareType: 0,
  radioGain: 0,
  alwaysOnTop: false,
  consentedToTelemetry: undefined,
};
const store = new Store();

const saveConfig = () => {
  store.set("configuration", JSON.stringify(currentConfiguration));
};

const setAudioSettings = () => {
  TrackAudioAfv.SetAudioSettings(
    currentConfiguration.audioApi || -1,
    currentConfiguration.audioInputDeviceId || "",
    currentConfiguration.headsetOutputDeviceId || "",
    currentConfiguration.speakerOutputDeviceId || "",
  );
  TrackAudioAfv.SetHardwareType(currentConfiguration.hardwareType || 0);
};

const setupUiHook = () => {
  uIOhook.on("keydown", (e) => {
    if (isSettingPtt) {
      currentConfiguration.pttKey = e.keycode;
      currentConfiguration.pttKeyName = keycodeMap.get(e.keycode) ?? "Unknown";
      saveConfig();
      isSettingPtt = false;

      mainWindow.webContents.send("ptt-key-set", keycodeMap.get(e.keycode));
    } else {
      if (e.keycode == currentConfiguration.pttKey && e.keycode != 0) {
        TrackAudioAfv.SetPtt(true);
      }
    }
  });

  uIOhook.on("keyup", (e) => {
    if (e.keycode == currentConfiguration.pttKey && e.keycode != 0) {
      TrackAudioAfv.SetPtt(false);
    }
  });

  uIOhook.start();
};

const createWindow = (): void => {
  // Set the store CID
  TrackAudioAfv.SetCid(currentConfiguration.cid || "");
  TrackAudioAfv.SetRadioGain(currentConfiguration.radioGain || 0.5);

  version = TrackAudioAfv.GetVersion();

  // Create the browser window.
  mainWindow = new BrowserWindow({
    height: 660,
    width: 800,
    minWidth: 210,
    minHeight: 120,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
    // Required to handle resetting the zoom level to 1.0 on app launch
    show: false,
  });

  mainWindow.setAlwaysOnTop(currentConfiguration.alwaysOnTop || false);

  // Reset the zoom level to 1.0 on app launch. This is to work around a long-standing
  // bug in Electron that was opened in 2017 and closed without fixing. See
  // https://github.com/electron/electron/issues/10572 for more details.
  mainWindow.once("ready-to-show", () => {
    mainWindow.webContents.zoomFactor = 1.0;
  });

  if (process.platform !== "darwin") {
    mainWindow.setMenu(null);
  }
  // and load the index.html of the app.
  void mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  setupUiHook();
  // Open the DevTools only in development mode.
  if (process.env.NODE_ENV === "development") {
    mainWindow.webContents.openDevTools();
  }

  mainWindow.on("close", (e) => {
    if (TrackAudioAfv.IsConnected()) {
      const response = dialog.showMessageBoxSync(mainWindow, {
        type: "question",
        buttons: ["Yes", "No"],
        title: "Confirm",
        message: "Are you sure you want to quit?",
      });

      if (response == 1) {
        e.preventDefault();
      }
    }
  });

  // Support setting window zoom via ctrl + mouse wheel
  mainWindow.webContents.on("zoom-changed", (_, zoomDirection) => {
    const currentZoom = mainWindow.webContents.getZoomFactor();
    const newZoom =
      zoomDirection === "in"
        ? currentZoom + ZOOM_DELTA
        : currentZoom - ZOOM_DELTA;

    // Cap the zoom level between 100% and 300%. There's a setVisualZoomLevelLimits() in electron
    // but it's async, and also appears to only limit the pinch-to-zoom level, not the zoom level
    // set via setZoomFactor().
    if (newZoom > 1 && newZoom < 3) {
      mainWindow.webContents.setZoomFactor(newZoom);
    }
  });

  mainWindow.show();
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on("ready", () => {
  // load the configuration
  currentConfiguration = JSON.parse(
    store.get("configuration", "{}") as string,
  ) as Configuration;

  if (currentConfiguration.consentedToTelemetry === undefined) {
    // We have not recorded any telemetry consent yet, so we will prompt the user
    const response = dialog.showMessageBoxSync(mainWindow, {
      type: "question",
      buttons: ["I consent to telemetry", "I want to opt out"],
      title: "Telemetry consent",
      detail:
        "Only essential information from the crash report is sent, and no data leaves your device unless an error occurs. We do not record your IP address or VATSIM password. Your data would be sent to a third-party service, Sentry, to their servers located in Germany. This is entirely optional, but greatly assists in tracking down errors.",
      message:
        "TrackAudio utilizes remote telemetry in the event of a bug, sending an error report to a tool called Sentry.",
    });

    if (response === 0) {
      currentConfiguration.consentedToTelemetry = true;
    } else {
      currentConfiguration.consentedToTelemetry = false;
    }
    saveConfig();
  }

  if (currentConfiguration.consentedToTelemetry) {
    console.log("User opted into telemetry, enabling sentry");
    const sclient = Sentry.getClient();
    if (sclient) {
      // Disable sentry in debug always
      sclient.getOptions().enabled = !app.isPackaged
        ? false
        : currentConfiguration.consentedToTelemetry;
    } else {
      console.error("Could not enable sentry");
    }
  }

  if (
    process.platform === "darwin" &&
    !systemPreferences.isTrustedAccessibilityClient(true)
  ) {
    dialog.showMessageBoxSync({
      type: "info",
      message:
        "This application requires accessibility permissions (for push to talk to work). Please grant these in System Preferences.",
      buttons: ["OK"],
    });
  }

  const requiresUpdate = TrackAudioAfv.Bootstrap(process.resourcesPath);

  if (!requiresUpdate) {
    dialog.showMessageBoxSync({
      type: "error",
      message:
        "A new mandatory version is available, please update in order to continue.",
      buttons: ["OK"],
    });
    app.quit();
  }

  createWindow();
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
  TrackAudioAfv.Exit();
  uIOhook.stop();
  app.quit();
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
ipcMain.on("set-always-on-top", (_, state: boolean) => {
  mainWindow.setAlwaysOnTop(state);
  currentConfiguration.alwaysOnTop = state;
  saveConfig();
});

ipcMain.handle("audio-get-apis", () => {
  return TrackAudioAfv.GetAudioApis();
});

ipcMain.handle("audio-get-input-devices", (_, apiId: string) => {
  return TrackAudioAfv.GetAudioInputDevices(apiId);
});

ipcMain.handle("audio-get-output-devices", (_, apiId: string) => {
  return TrackAudioAfv.GetAudioOutputDevices(apiId);
});

ipcMain.handle("get-configuration", () => {
  return currentConfiguration;
});

//
// AFV audio settings
//

ipcMain.handle("set-audio-input-device", (_, deviceId: string) => {
  currentConfiguration.audioInputDeviceId = deviceId;
  saveConfig();
});

ipcMain.handle("set-headset-output-device", (_, deviceId: string) => {
  currentConfiguration.headsetOutputDeviceId = deviceId;
  saveConfig();
});

ipcMain.handle("set-speaker-output-device", (_, deviceId: string) => {
  currentConfiguration.speakerOutputDeviceId = deviceId;
  saveConfig();
});

ipcMain.handle("set-audio-api", (_, apiId: number) => {
  currentConfiguration.audioApi = apiId;
  saveConfig();
});

//
// AFV login settings
//

ipcMain.handle("set-cid", (_, cid: string) => {
  currentConfiguration.cid = cid;
  saveConfig();
  TrackAudioAfv.SetCid(cid);
});

ipcMain.handle("set-password", (_, password: string) => {
  currentConfiguration.password = password;
  saveConfig();
});

//
// AFV actions
//

ipcMain.handle("connect", () => {
  if (!currentConfiguration.password || !currentConfiguration.cid) {
    return false;
  }
  setAudioSettings();
  return TrackAudioAfv.Connect(currentConfiguration.password);
});

ipcMain.handle("disconnect", () => {
  TrackAudioAfv.Disconnect();
});

ipcMain.handle(
  "audio-add-frequency",
  (_, frequency: number, callsign: string) => {
    return TrackAudioAfv.AddFrequency(frequency, callsign);
  },
);

ipcMain.handle("audio-remove-frequency", (_, frequency: number) => {
  TrackAudioAfv.RemoveFrequency(frequency);
});

ipcMain.handle(
  "audio-set-frequency-state",
  (
    _,
    frequency: number,
    rx: boolean,
    tx: boolean,
    xc: boolean,
    onSpeaker: boolean,
    crossCoupleAcross: boolean,
  ) => {
    return TrackAudioAfv.SetFrequencyState(
      frequency,
      rx,
      tx,
      xc,
      onSpeaker,
      crossCoupleAcross,
    );
  },
);

ipcMain.handle("audio-get-frequency-state", (_, frequency: number) => {
  return TrackAudioAfv.GetFrequencyState(frequency);
});

ipcMain.handle("audio-is-frequency-active", (_, frequency: number) => {
  return TrackAudioAfv.IsFrequencyActive(frequency);
});

ipcMain.handle("get-station", (_, callsign: string) => {
  TrackAudioAfv.GetStation(callsign);
});

ipcMain.handle("refresh-station", (_, callsign: string) => {
  TrackAudioAfv.RefreshStation(callsign);
});

ipcMain.handle("setup-ptt", () => {
  isSettingPtt = true;
});

ipcMain.handle("set-radio-gain", (_, gain: number) => {
  TrackAudioAfv.SetRadioGain(gain);
  currentConfiguration.radioGain = gain;
  saveConfig();
});

ipcMain.handle("set-hardware-type", (_, type: number) => {
  currentConfiguration.hardwareType = type;
  saveConfig();
  TrackAudioAfv.SetHardwareType(type);
});

ipcMain.handle("start-mic-test", () => {
  setAudioSettings();
  TrackAudioAfv.StartMicTest();
});

ipcMain.handle("stop-mic-test", () => {
  mainWindow.webContents.send("MicTest", "0.0", "0.0");
  TrackAudioAfv.StopMicTest();
});

ipcMain.handle("update-platform", () => {
  return process.platform;
});

ipcMain.handle("close-me", () => {
  mainWindow.close();
});

ipcMain.handle("change-telemetry", (_, enabled: boolean) => {
  currentConfiguration.consentedToTelemetry = enabled;
  const sclient = Sentry.getClient();
  if (sclient) {
    sclient.getOptions().enabled = enabled;
  }
  saveConfig();
});

ipcMain.handle("should-enable-renderer-telemetry", () => {
  return !app.isPackaged ? false : currentConfiguration.consentedToTelemetry;
});

ipcMain.handle(
  "dialog",
  (
    _,
    type: "none" | "info" | "error" | "question" | "warning",
    title: string,
    message: string,
    buttons: string[],
  ) => {
    return dialog.showMessageBox(mainWindow, {
      type,
      title,
      buttons,
      message,
    });
  },
);

ipcMain.handle("get-version", () => {
  return version;
});

//
// Callbacks
//
TrackAudioAfv.RegisterCallback((arg: string, arg2: string, arg3: string) => {
  if (!arg) {
    return;
  }

  if (arg === AfvEventTypes.VuMeter) {
    mainWindow.webContents.send("VuMeter", arg2, arg3);
  }

  if (arg === AfvEventTypes.FrequencyRxBegin) {
    mainWindow.webContents.send("FrequencyRxBegin", arg2);
  }

  if (arg === AfvEventTypes.FrequencyRxEnd) {
    mainWindow.webContents.send("FrequencyRxEnd", arg2);
  }

  if (arg == AfvEventTypes.StationRxBegin) {
    mainWindow.webContents.send("StationRxBegin", arg2, arg3);
  }

  if (arg == AfvEventTypes.StationTransceiversUpdated) {
    mainWindow.webContents.send("station-transceivers-updated", arg2, arg3);
  }

  if (arg == AfvEventTypes.StationDataReceived) {
    mainWindow.webContents.send("station-data-received", arg2, arg3);
  }

  if (arg == AfvEventTypes.PttState) {
    mainWindow.webContents.send("PttState", arg2);
  }

  if (arg == AfvEventTypes.Error) {
    mainWindow.webContents.send("error", arg2);
  }

  if (arg == AfvEventTypes.VoiceConnected) {
    mainWindow.webContents.send("VoiceConnected");
  }

  if (arg == AfvEventTypes.VoiceDisconnected) {
    mainWindow.webContents.send("VoiceDisconnected");
  }

  if (arg == AfvEventTypes.NetworkConnected) {
    mainWindow.webContents.send("network-connected", arg2, arg3);
  }

  if (arg == AfvEventTypes.NetworkDisconnected) {
    mainWindow.webContents.send("network-disconnected");
  }
});
