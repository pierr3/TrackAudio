import {
  app,
  BrowserWindow,
  dialog,
  ipcMain,
  systemPreferences,
} from "electron";

import { TrackAudioAfv, AfvEventTypes } from "trackaudio-afv";
import { Configuration } from "./config.d";
import Store from "electron-store";
import { uIOhook } from "uiohook-napi";
import { getKeyFromNumber } from "./helper";

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// The increment for window zoom with each mouse wheel movement
const ZOOM_DELTA = 0.2;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) app.quit();

let version = "";
let mainWindow: BrowserWindow;

let isSettingPtt = false;

let currentConfiguration: Configuration = {
  audioApi: -1,
  audioInputDeviceId: "",
  headsetOutputDeviceId: "",
  speakerOutputDeviceId: "",
  cid: "",
  password: "",
  callsign: "",
  pttKey: 0,
  hardwareType: 0,
  radioGain: 0,
  alwaysOnTop: false,
};
const store = new Store();

const saveConfig = () => {
  store.set("configuration", JSON.stringify(currentConfiguration));
};

const setAudioSettings = () => {
  TrackAudioAfv.SetAudioSettings(
    currentConfiguration.audioApi || -1,
    currentConfiguration.audioInputDeviceId || "",
    currentConfiguration.headsetOutputDeviceId || "",
    currentConfiguration.speakerOutputDeviceId || ""
  );
  TrackAudioAfv.SetHardwareType(currentConfiguration.hardwareType || 0);
};

const setupUiHook = () => {
  uIOhook.on("keydown", (e) => {
    if (isSettingPtt) {
      currentConfiguration.pttKey = e.keycode;
      saveConfig();
      isSettingPtt = false;

      mainWindow.webContents.send("ptt-key-set", getKeyFromNumber(e.keycode));
    } else {
      if (e.keycode == currentConfiguration.pttKey && e.keycode != 0) {
        TrackAudioAfv.SetPtt(true);
      }
    }
  });

  uIOhook.on("keyup", (e) => {
    if (e.keycode == currentConfiguration.pttKey && e.keycode != 0) {
      TrackAudioAfv.SetPtt(false);
    }
  });

  uIOhook.start();
};

const createWindow = (): void => {
  // load the configuration
  currentConfiguration = JSON.parse(
    store.get("configuration", "{}") as string
  ) as Configuration;

  // Set the store CID
  TrackAudioAfv.SetCid(currentConfiguration.cid || "");
  TrackAudioAfv.SetRadioGain(currentConfiguration.radioGain || 0.5);

  version = TrackAudioAfv.GetVersion();

  // Create the browser window.
  mainWindow = new BrowserWindow({
    height: 660,
    width: 800,
    minWidth: 200,
    minHeight: 120,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
    // Required to handle resetting the zoom level to 1.0 on app launch
    show: false,
  });

  mainWindow.setAlwaysOnTop(currentConfiguration.alwaysOnTop || false);

  // Reset the zoom level to 1.0 on app launch. This is to work around a long-standing
  // bug in Electron that was opened in 2017 and closed without fixing. See
  // https://github.com/electron/electron/issues/10572 for more details.
  mainWindow.once("ready-to-show", () => {
    mainWindow.webContents.zoomFactor = 1.0;
  });

  if (process.platform !== "darwin") {
    mainWindow.setMenu(null);
  }
  // and load the index.html of the app.
  void mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  setupUiHook();
  // Open the DevTools only in development mode.
  if (process.env.NODE_ENV === "development") {
    mainWindow.webContents.openDevTools();
  }

  mainWindow.on("close", (e) => {
    if (TrackAudioAfv.IsConnected()) {
      const response = dialog.showMessageBoxSync(mainWindow, {
        type: "question",
        buttons: ["Yes", "No"],
        title: "Confirm",
        message: "Are you sure you want to quit?",
      });

      if (response == 1) {
        e.preventDefault();
      }
    }
  });

  // Support setting window zoom via ctrl + mouse wheel
  mainWindow.webContents.on("zoom-changed", (_, zoomDirection) => {
    const currentZoom = mainWindow.webContents.getZoomFactor();
    const newZoom =
      zoomDirection === "in"
        ? currentZoom + ZOOM_DELTA
        : currentZoom - ZOOM_DELTA;

    // Cap the zoom level between 100% and 300%. There's a setVisualZoomLevelLimits() in electron
    // but it's async, and also appears to only limit the pinch-to-zoom level, not the zoom level
    // set via setZoomFactor().
    if (newZoom > 1 && newZoom < 3) {
      mainWindow.webContents.setZoomFactor(newZoom);
    }
  });

  mainWindow.show();
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on("ready", () => {
  const requiresUpdate = TrackAudioAfv.Bootstrap(process.resourcesPath);

  if (!requiresUpdate) {
    dialog.showMessageBoxSync({
      type: "error",
      message:
        "A new mandatory version is available, please update in order to continue.",
      buttons: ["OK"],
    });
    app.quit();
  }

  if (
    process.platform === "darwin" &&
    !systemPreferences.isTrustedAccessibilityClient(true)
  ) {
    dialog.showMessageBoxSync({
      type: "info",
      message:
        "This application requires accessibility permissions (for push to talk to work). Please grant these in System Preferences.",
      buttons: ["OK"],
    });
  }

  createWindow();
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
  TrackAudioAfv.Exit();
  app.quit();
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
ipcMain.on("set-always-on-top", (_, state: boolean) => {
  mainWindow.setAlwaysOnTop(state);
  currentConfiguration.alwaysOnTop = state;
  saveConfig();
});

ipcMain.handle("audio-get-apis", () => {
  return TrackAudioAfv.GetAudioApis();
});

ipcMain.handle("audio-get-input-devices", (_, apiId: string) => {
  return TrackAudioAfv.GetAudioInputDevices(apiId);
});

ipcMain.handle("audio-get-output-devices", (_, apiId: string) => {
  return TrackAudioAfv.GetAudioOutputDevices(apiId);
});

ipcMain.handle("get-configuration", () => {
  return currentConfiguration;
});

//
// AFV audio settings
//

ipcMain.handle("set-audio-input-device", (_, deviceId: string) => {
  currentConfiguration.audioInputDeviceId = deviceId;
  saveConfig();
});

ipcMain.handle("set-headset-output-device", (_, deviceId: string) => {
  currentConfiguration.headsetOutputDeviceId = deviceId;
  saveConfig();
});

ipcMain.handle("set-speaker-output-device", (_, deviceId: string) => {
  currentConfiguration.speakerOutputDeviceId = deviceId;
  saveConfig();
});

ipcMain.handle("set-audio-api", (_, apiId: number) => {
  currentConfiguration.audioApi = apiId;
  saveConfig();
});

//
// AFV login settings
//

ipcMain.handle("set-cid", (_, cid: string) => {
  currentConfiguration.cid = cid;
  saveConfig();
  TrackAudioAfv.SetCid(cid);
});

ipcMain.handle("set-password", (_, password: string) => {
  currentConfiguration.password = password;
  saveConfig();
});

//
// AFV actions
//

ipcMain.handle("connect", () => {
  if (!currentConfiguration.password || !currentConfiguration.cid) {
    return false;
  }
  setAudioSettings();
  return TrackAudioAfv.Connect(currentConfiguration.password);
});

ipcMain.handle("disconnect", () => {
  TrackAudioAfv.Disconnect();
});

ipcMain.handle(
  "audio-add-frequency",
  (_, frequency: number, callsign: string) => {
    return TrackAudioAfv.AddFrequency(frequency, callsign);
  }
);

ipcMain.handle("audio-remove-frequency", (_, frequency: number) => {
  TrackAudioAfv.RemoveFrequency(frequency);
});

ipcMain.handle(
  "audio-set-frequency-state",
  (
    _,
    frequency: number,
    rx: boolean,
    tx: boolean,
    xc: boolean,
    onSpeaker: boolean,
    crossCoupleAcross: boolean
  ) => {
    return TrackAudioAfv.SetFrequencyState(
      frequency,
      rx,
      tx,
      xc,
      onSpeaker,
      crossCoupleAcross
    );
  }
);

ipcMain.handle("audio-get-frequency-state", (_, frequency: number) => {
  return TrackAudioAfv.GetFrequencyState(frequency);
});

ipcMain.handle("audio-is-frequency-active", (_, frequency: number) => {
  return TrackAudioAfv.IsFrequencyActive(frequency);
});

ipcMain.handle("get-station", (_, callsign: string) => {
  TrackAudioAfv.GetStation(callsign);
});

ipcMain.handle("refresh-station", (_, callsign: string) => {
  TrackAudioAfv.RefreshStation(callsign);
});

ipcMain.handle("setup-ptt", () => {
  isSettingPtt = true;
});

ipcMain.handle("set-radio-gain", (_, gain: number) => {
  TrackAudioAfv.SetRadioGain(gain);
  currentConfiguration.radioGain = gain;
  saveConfig();
});

ipcMain.handle("set-hardware-type", (_, type: number) => {
  currentConfiguration.hardwareType = type;
  saveConfig();
  TrackAudioAfv.SetHardwareType(type);
});

ipcMain.handle("start-mic-test", () => {
  setAudioSettings();
  TrackAudioAfv.StartMicTest();
});

ipcMain.handle("stop-mic-test", () => {
  mainWindow.webContents.send("MicTest", "0.0", "0.0");
  TrackAudioAfv.StopMicTest();
});

ipcMain.handle("update-platform", () => {
  return process.platform;
});

ipcMain.handle("close-me", () => {
  app.quit();
});

ipcMain.handle(
  "dialog",
  (
    _,
    type: "none" | "info" | "error" | "question" | "warning",
    title: string,
    message: string,
    buttons: string[]
  ) => {
    return dialog.showMessageBox(mainWindow, {
      type,
      title,
      buttons,
      message,
    });
  }
);

ipcMain.handle("get-version", () => {
  return version;
});

//
// Callbacks
//
TrackAudioAfv.RegisterCallback((arg: string, arg2: string, arg3: string) => {
  if (!arg) {
    return;
  }

  if (arg === AfvEventTypes.VuMeter) {
    mainWindow.webContents.send("VuMeter", arg2, arg3);
  }

  if (arg === AfvEventTypes.FrequencyRxBegin) {
    mainWindow.webContents.send("FrequencyRxBegin", arg2);
  }

  if (arg === AfvEventTypes.FrequencyRxEnd) {
    mainWindow.webContents.send("FrequencyRxEnd", arg2);
  }

  if (arg == AfvEventTypes.StationRxBegin) {
    mainWindow.webContents.send("StationRxBegin", arg2, arg3);
  }

  if (arg == AfvEventTypes.StationTransceiversUpdated) {
    mainWindow.webContents.send("station-transceivers-updated", arg2, arg3);
  }

  if (arg == AfvEventTypes.StationDataReceived) {
    mainWindow.webContents.send("station-data-received", arg2, arg3);
  }

  if (arg == AfvEventTypes.PttState) {
    mainWindow.webContents.send("PttState", arg2);
  }

  if (arg == AfvEventTypes.Error) {
    mainWindow.webContents.send("error", arg2);
  }

  if (arg == AfvEventTypes.VoiceConnected) {
    mainWindow.webContents.send("VoiceConnected");
  }

  if (arg == AfvEventTypes.VoiceDisconnected) {
    mainWindow.webContents.send("VoiceDisconnected");
  }

  if (arg == AfvEventTypes.NetworkConnected) {
    mainWindow.webContents.send("network-connected", arg2, arg3);
  }

  if (arg == AfvEventTypes.NetworkDisconnected) {
    mainWindow.webContents.send("network-disconnected");
  }
});
